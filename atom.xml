<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Grace&#39;s Space</title>
  
  <subtitle>We are all explorers trying to find ourselves.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gracee.xin/"/>
  <updated>2018-03-28T09:53:55.124Z</updated>
  <id>http://gracee.xin/</id>
  
  <author>
    <name>Gracee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>僵尸进程与孤儿进程</title>
    <link href="http://gracee.xin/2018/03/16/zombieandorphanpid/"/>
    <id>http://gracee.xin/2018/03/16/zombieandorphanpid/</id>
    <published>2018-03-16T07:25:00.000Z</published>
    <updated>2018-03-28T09:53:55.124Z</updated>
    
    <content type="html"><![CDATA[<p>【转】  </p><p>作者：郭无心</p><p>链接：<a href="https://www.zhihu.com/question/26432067/answer/70643183" target="_blank" rel="external">https://www.zhihu.com/question/26432067/answer/70643183</a></p><p>来源：知乎</p><p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>在Unix系统编程中，常常会碰到两个概念：僵尸进程和孤儿进程。话说我以前曾经把这两个概念弄混淆过。<br><a id="more"></a></p><h5 id="什么是僵尸进程？"><a href="#什么是僵尸进程？" class="headerlink" title="什么是僵尸进程？"></a>什么是僵尸进程？</h5><p>Unix进程模型中，进程是按照父进程产生子进程，子进程产生子子进程这样的方式创建出完成各项相互协作功能的进程的。当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。如果父进程没有这么做的话，会产生什么后果呢？此时，子进程虽然已经退出了，但是在系统进程表中还为它保留了一些退出状态的信息，如果父进程一直不取得这些退出信息的话，这些进程表项就将一直被占用，此时，这些占着茅坑不拉屎的子进程就成为“僵尸进程”（zombie）。系统进程表是一项有限资源，如果系统进程表被僵尸进程耗尽的话，系统就可能无法创建新的进程。  </p><h5 id="那么，孤儿进程又是怎么回事呢？"><a href="#那么，孤儿进程又是怎么回事呢？" class="headerlink" title="那么，孤儿进程又是怎么回事呢？"></a>那么，孤儿进程又是怎么回事呢？</h5><p>孤儿进程是指这样一类进程：在进程还未退出之前，它的父进程就已经退出了，一个没有了父进程的子进程就是一个孤儿进程（orphan）。既然所有进程都必须在退出之后被wait()或waitpid()以释放其遗留在系统中的一些资源，那么应该由谁来处理孤儿进程的善后事宜呢？这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程“凄凉地”结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。  </p><p><strong>这样来看，孤儿进程并不会有什么危害，真正会对系统构成威胁的是僵尸进程。</strong>  </p><p>那么，什么情况下僵尸进程会威胁系统的稳定呢？  </p><p>设想有这样一个父进程：它定期的产生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短，但是，父进程只管生成新的子进程，至于子进程退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵尸进程，倘若用ps命令查看的话，就会看到很多状态为Z的进程。<br>严格地来说，僵尸进程并不是问题的根源，罪魁祸首是产生出大量僵尸进程的那个父进程。  </p><p>因此，当我们寻求如何消灭系统中大量的僵尸进程时，答案就是把产生大量僵尸进程的那个元凶枪毙掉（通过kill发送SIGTERM或者SIGKILL信号）。  </p><p>枪毙了元凶进程之后，它产生的僵尸进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经“僵尸”的孤儿进程就能瞑目而去了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【转】  &lt;/p&gt;
&lt;p&gt;作者：郭无心&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.zhihu.com/question/26432067/answer/70643183&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.zhihu.com/question/26432067/answer/70643183&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：知乎&lt;/p&gt;
&lt;p&gt;著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/p&gt;
&lt;p&gt;在Unix系统编程中，常常会碰到两个概念：僵尸进程和孤儿进程。话说我以前曾经把这两个概念弄混淆过。&lt;br&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://gracee.xin/tags/linux/"/>
    
      <category term="pid" scheme="http://gracee.xin/tags/pid/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM-Note-Java内存区域与内存溢出异常</title>
    <link href="http://gracee.xin/2018/01/12/jvm-2/"/>
    <id>http://gracee.xin/2018/01/12/jvm-2/</id>
    <published>2018-01-12T10:50:00.000Z</published>
    <updated>2018-03-28T09:54:52.491Z</updated>
    
    <content type="html"><![CDATA[<p>《深入理解Java虚拟机》第二章阅读笔记<br>笔记基本只作为记录。<br><a id="more"></a></p><h4 id="一、jvm运行时数据区域"><a href="#一、jvm运行时数据区域" class="headerlink" title="一、jvm运行时数据区域"></a>一、jvm运行时数据区域</h4><p>灰色区域：是线程共享的数据区<br>白色区域：是线程私有的数据区<br><img src="/images/jvm-2-1.png"><br><strong>1. 程序计数器:当前线程所执行的字节码的行号指示器,线程私有的。</strong>  </p><p>如果线程正执行的是一个Java方法，<strong>这个计数器记录的是正在执行的虚拟机字节码指令的地址</strong>；<br>如果正在执行的是Native方法，这个计数器值则为空（Undefined）。<br>此内存区域是<strong>唯一一个</strong>在Java虚拟机规范中<strong>没有规定任何OutOfMemoryError情况的区域</strong>。  </p><p><strong>2.Java虚拟机栈：生命周期与线程相同，线程私有的。</strong>  </p><p>虚拟机栈描述的是<strong>Java方法执行的内存模型</strong>：每个方法在执行的同时都会创建一个<strong>栈帧Stack  Frame</strong>用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。<br>虚拟机栈的局部变量表存放了编译器可知的各种基本类型、对象引用、returnAddress类型，其中64位的long和double类型会占用2个slot（局部变量空间），其余只占用1个。方法运行期间局部变量表的大小不会改变。<br>如果线程请求的栈深度大于虚拟机允许的深度，将抛出<strong>StackOverflowError异常</strong>。<br>如果虚拟机栈可以动态扩展，且扩展时无法申请足够的内存，将抛出<strong>OutOfMemoryError异常</strong>。  </p><p><strong>3.本地方法栈</strong>  </p><p>与虚拟机栈作用十分相似，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而<strong>本地方法栈则为虚拟机使用到的Native方法服务</strong>。  </p><p><strong>4.Java堆</strong>  </p><p>Java堆是Java虚拟机所管理的内存中最大的一块，被所有线程共享，在虚拟机启动时创建。<br>此内存区域的<strong>唯一目的就是存放对象实例</strong>，<strong>几乎</strong>所有的对象实例都在这里分配内存。<br>Java堆是垃圾收集器管理的主要区域，因此很多时候被称“<strong>GC堆</strong>”（GarbageCollected Heap）。<br>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。  </p><p><strong>5.方法区</strong>  </p><p>方法区也是各个线程共享的内存区域，用于存储<strong>已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。<br>java虚拟机对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择<strong>不实现垃圾收集</strong>。垃圾收集行为在这个区域较少出现，但并非数据就永久存在。这个区域的内存回收目标主要是<strong>针对常量池的回收和类型的卸载</strong>，回收难以令人满意。<br>运行时常量池是方法区的一部分，class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池，用于存放编译期生成的各种字面量和符号引用（？），这部分内容将在<strong>类加载后进入方法区的运行时常量池中存放</strong>。<br>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，<strong>运行期间也可能将新的常量放入池中</strong>，这种特性被开发人员利用得比较多的便是String类的intern()方法。<br>常量池无法再申请到内存时会抛出OutOfMemoryError异常。  </p><h4 id="二、直接内存"><a href="#二、直接内存" class="headerlink" title="二、直接内存"></a>二、直接内存</h4><p>不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。<br>NIO:基于通道（Channel）与缓冲区（Buffer）的的I/O方式。它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。<br>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出OutOfMemoryError异常。  </p><h4 id="三、HotSpot虚拟机对象"><a href="#三、HotSpot虚拟机对象" class="headerlink" title="三、HotSpot虚拟机对象"></a>三、HotSpot虚拟机对象</h4><p><strong>1.对象的创建</strong>  </p><p>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须（1）<strong><em>先执行相应的类加载过程</em></strong>。<br>在类加载检查通过后，接下来虚拟机将（2）<strong><em>为新生对象分配内存</em></strong>。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。分配内存的方式有“<strong>指针碰撞</strong>”和“<strong>空闲列表</strong>”两种。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。<br><strong>指针碰撞</strong>：假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump the Pointer）。<br><strong>空闲列表</strong>：如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free  List）。<br>除如何划分可用空间之外，还有另外一个需要考虑的问题是<strong>对象创建的线程安全性</strong>。<br>对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。<br>解决这个问题有两种方案，<strong>一种是对分配内存空间的动作进行同步处理</strong>（虚拟机采用CAS配上失败重试的方式保证更新操作的原子性）；<strong>另一种是把内存分配的动作按照线程划分在不同的空间之中进行</strong>，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲(TLAB)。<br>内存分配完成后，虚拟机需要（3）<strong><em>将分配到的内存空间都初始化为零值</em></strong>（不包括对象头）。<br>接下来，（4）<strong><em>设置对象头</em></strong>：虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。<br>一个新的对象已经产生，但初始化尚未进行，所有字段还为零，所以在new指令后，（5）<strong><em>最后一般会接着执行init方法</em></strong>（构造方法）。这样一个真正可用的对象才算完全产生出来。  </p><p><strong>2.对象的内存布局</strong>  </p><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。<br>（1）<strong>对象头</strong>包括两部分信息：<br><strong><em>一部分用于存储对象自身的运行时数据Mark Word</em></strong>（哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，长度由虚拟机位数（32位/64位）决定，往往对象需要存储的运行时数据很多，不止32/64bit，但它会根据对象状态复用自己的存储空间）；<br><strong><em>另一部分是类型指针</em></strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。<br>（2）<strong>实例数据</strong>：<br>实例数据是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的<strong>存储顺序</strong>会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响。<br>HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，<strong>相同宽度的字段总是被分配到一起</strong>。在满足这个前提条件的情况下，在<strong>父类中定义的变量会出现在子类之前</strong>。如果CompactFields参数值为true（默认为true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。<br>（3）<strong>对齐填充</strong>：<br>并不必然存在，仅仅起着占位符作用。<br>HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。  </p><p><strong>3.对象的访问定位</strong>  </p><p>建立对象是为了使用对象，我们的Java程序需要通过栈（java虚拟机栈，局部变量表）上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中<strong>只规定了一个指向对象的引用</strong>，并没有定义这个引用应该通过何种方式去访问堆中的对象的具体位置，所以<strong>对象访问方式</strong>也是取决于虚拟机实现而定的。目前主流的访问方式有使用句柄和直接指针两种。<br><strong>句柄访问</strong>：Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。<br><img src="/images/jvm-2-2.png"></p><p><strong>直接指针访问</strong>：Java堆对象的布局中必须考虑如何访问对象类型数据，而reference中存储的直接就是对象地址。<br><img src="/images/jvm-2-3.png"></p><p><em>两种方式对比：</em><br>使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。<br>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。  </p><h4 id="四、实战OutOfMemoryError异常"><a href="#四、实战OutOfMemoryError异常" class="headerlink" title="四、实战OutOfMemoryError异常"></a>四、实战OutOfMemoryError异常</h4><p>在Java虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError（OOM）异常的可能。  </p><p><strong>1.Java堆溢出</strong>  </p><p>Java堆用于存储对象实例，如果不断地创建对象，且保证GC Roots到对象之间有可达路径，能避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。<br><strong>实例</strong>：限制Java堆的大小为20MB，不可扩展（将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展），通过参数-XX：+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的<strong>内存堆转储快照</strong>以便事后进行分析。<br><strong>代码2-3-java堆内存溢出异常测试：</strong>  </p><pre><code class="java"><span class="comment">/** *VM Args:-Xms20m-Xmx20m-XX:+HeapDumpOnOutOfMemoryError *<span class="doctag">@author</span> zzm */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span></span>{    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>{    }    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>{        List&lt;OOMObject&gt;list=<span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();        <span class="keyword">while</span>(<span class="keyword">true</span>){            list.add(<span class="keyword">new</span> OOMObject());        }    }}</code></pre><p><strong>运行结果：</strong></p><pre><code class="java">java.lang.OutOfMemoryError:Java heap space    Dumping heap to java_pid3404.hprof……    Heap dump file created[<span class="number">22045981</span> bytes in <span class="number">0.663</span> secs]</code></pre><p><strong>解决方案：</strong><br>Java堆内存的OOM异常是实际应用中常见的内存溢出异常情况。当出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space”。<br>要解决这个区域的异常，一般的手段是先通过内存映像分析工具对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了<strong>内存泄漏</strong>（Memory  Leak）还是<strong>内存溢出</strong>（Memory Overflow）。<br>如果是内存泄露，可进一步通过工具<strong>查看泄露对象到GC Roots的引用链</strong>。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄露对象的类型信息及GC  Roots引用链的信息，就可以比较准确地定位出泄露代码的位置。<br>如果不存在泄露，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理<strong>内存</strong>对比看<strong>是否还可以调大</strong>，从代码上检查<strong>是否存在某些对象生命周期过长、持有状态时间过长的情况</strong>，尝试减少程序运行期的内存消耗。  </p><p><strong>2.虚拟机栈和本地方法栈溢出</strong>  </p><p>在HotSpot虚拟机中，栈容量只由-Xss参数设定。<br>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。<br>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。<br>这里把异常分成两种情况，看似更加严谨，但却存在着一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事情的两种描述而已。<br><strong>实例</strong>：定义了大量的本地变量，增大此方法帧中本地变量表的长度。<br><strong>代码2-4-虚拟机栈和本地方法栈OOM测试（仅作为第1点测试程序）：</strong></p><pre><code class="java"><span class="comment">/** *VM Args:-Xss128k *<span class="doctag">@author</span> zzm */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span></span>{    <span class="keyword">private</span> <span class="keyword">int</span> stackLength=<span class="number">1</span>;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span></span>{        stackLength++;        stackLeak();    }    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span><span class="keyword">throws</span> Throwable</span>{        JavaVMStackSOF oom=<span class="keyword">new</span> JavaVMStackSOF();        <span class="keyword">try</span>{            oom.stackLeak();        }<span class="keyword">catch</span>(Throwable e){            System.out.println(<span class="string">"stack length:"</span>+oom.stackLength);            <span class="keyword">throw</span> e;        }    }}</code></pre><p><strong>运行结果：</strong><br>在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无<br>法分配的时候，虚拟机抛出的都是StackOverflowError异常。  </p><pre><code class="java">stack length:<span class="number">2402</span>    Exception in thread<span class="string">"main"</span>java.lang.StackOverflowError    at org.fenixsoft.oom.VMStackSOF.leak(VMStackSOF.java:<span class="number">20</span>)    at org.fenixsoft.oom.VMStackSOF.leak(VMStackSOF.java:<span class="number">21</span>)    at org.fenixsoft.oom.VMStackSOF.leak(VMStackSOF.java:<span class="number">21</span>)    <span class="comment">//……后续异常堆栈信息省略</span></code></pre><p><strong>实例：</strong><br>测试时不限于单线程，通过不断地建立线程的方式倒是可以产生内存溢出异常。<br><strong>代码2-5-创建线程导致内存溢出异常：</strong></p><pre><code class="java"><span class="comment">/** *VM Args:-Xss2M(这时候不妨设置大些) *<span class="doctag">@author</span> zzm */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackOOM</span></span>{    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dontStop</span><span class="params">()</span></span>{        <span class="keyword">while</span>(<span class="keyword">true</span>){        }    }    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakByThread</span><span class="params">()</span></span>{        <span class="keyword">while</span>(<span class="keyword">true</span>){            Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable(){                <span class="meta">@Override</span>                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{                    dontStop();                }            });            thread.start();        }    }    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span><span class="keyword">throws</span> Throwable</span>{        JavaVMStackOOM oom=<span class="keyword">new</span> JavaVMStackOOM();        oom.stackLeakByThread();    }}</code></pre><p><strong>运行结果：</strong></p><pre><code class="java">Exception in thread<span class="string">"main"</span>java.lang.OutOfMemoryError:unable to create <span class="keyword">new</span> <span class="keyword">native</span> thread</code></pre><p><strong>两个实例的分析：</strong><br>单线程内存无法分配只会抛出StackOverflowError异常，<br>不断建立线程而产生了OutOfMemoryError异常。<br>这种情况下，为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。<br>譬如32位的Windows，限制为2GB。虚拟机提供了参数来控制Java堆和方法区的这两部分内存的最大值。剩余的内存为2GB（操作系统限制）减去Xmx（最大堆容量），再减去MaxPermSize（最大方法区容量），程序计数器消耗内存很小，可以忽略掉。如果虚拟机进程本身耗费的内存不算在内，剩下的内存就由<strong>多个线程的“虚拟机栈”和“本地方法栈”瓜分</strong>了。<br>所以：每个线程分配到的栈容量越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。OOM是指整个内存空间。<br>建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆（增大剩余空间）和<strong>减少栈容量??</strong>来换取更多的线程。如果没有这方面的处理经验，这种通过“减少内存”的手段来解决内存溢出的方式会比较难以想到。  </p><h5 id="3-方法区和运行时常量池溢出"><a href="#3-方法区和运行时常量池溢出" class="headerlink" title="3.方法区和运行时常量池溢出"></a>3.方法区和运行时常量池溢出</h5><p>String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。<br>JDK 1.6及之前的版本中，由于常量池分配在永久代（方法区）内，我们可以通过-XX：PermSize和-XX：MaxPermSize限制方法区大小，从而间接限制其中常量池的容量。<br>JDK1.7之后，常量池移到了堆中。<br><strong>代码2-7-String.intern()返回引用的测试：</strong>  </p><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span></span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>{        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>{            String str1=<span class="keyword">new</span> StringBuilder(<span class="string">"计算机"</span>).append(<span class="string">"软件"</span>).toString();            System.out.println(str1.intern()==str1);            String str2=<span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();            System.out.println(str2.intern()==str2);        }    }}</code></pre><p>这段代码在JDK 1.6中运行，会得到两个false，而在JDK 1.7中运行，会得到一个true和一个false。<br><strong>在JDK1.6中</strong>：str1.intern()方法会把首次遇到的字符串str1实例复制到永久代中，返回的也是<strong>永久代中这个字符串实例的引用</strong>，而由StringBuilder创建的字符串str1实例在Java堆上，所以必然不是同一个引用，str1.intern()==str1将返回false。<br><strong>而JDK1.7</strong>的intern()实现<strong>不会再复制实例</strong>，只在常量池中++记录++首次出现的实例引用，因此intern()返回的引用和由StringBuilder创建的那个字符串实例是同一个。<br>对str2比较返回false是因为“java”这个字符串在执行StringBuilder.toString()之前已经出现过，字符串常量池中已经有它的引用了，不符合“首次出现”的原则。？？？ </p><p><strong>方法区</strong>用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这些区域的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。下面这个实例借助CGLib直接操作字节码运行时生成了大量的动态类。  </p><p><strong>代码2-8-借助CGLib使方法区出现内存溢出异常：</strong></p><pre><code class="java"><span class="comment">/** *VM Args:-XX:PermSize=10M-XX:MaxPermSize=10M *<span class="doctag">@author</span> zzm */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMethodAreaOOM</span></span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>{        <span class="keyword">while</span>(<span class="keyword">true</span>){            Enhancer enhancer=<span class="keyword">new</span> Enhancer();            enhancer.setSuperclass(OOMObject.class);            enhancer.setUseCache(<span class="keyword">false</span>);            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor(){                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj,Method method,Object[]args,MethodProxy proxy)</span><span class="keyword">throws</span> Throwable</span>{                    <span class="keyword">return</span> proxy.invokeSuper(obj,args);                }            });            enhancer.create();        }    }    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>{    }}</code></pre><p><strong>运行结果：</strong></p><pre><code class="java">Caused by:java.lang.OutOfMemoryError:PermGen space    at java.lang.ClassLoader.defineClass1(Native Method)    at java.lang.ClassLoader.defineClassCond(ClassLoader.java:<span class="number">632</span>)    at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">616</span>)    <span class="comment">//……8 more</span></code></pre><p>方法区溢出也是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。这类场景除了上面提到的程序使用了CGLib字节码增强和动态语言之外，常见的还有：大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。  </p><h5 id="4-本机直接内存溢出"><a href="#4-本机直接内存溢出" class="headerlink" title="4.本机直接内存溢出"></a>4.本机直接内存溢出</h5><p>DirectMemory容量可通过-XX：MaxDirectMemorySize指定<br><strong>实例</strong>：越过了DirectByteBuffer类，直接通过反射获取Unsafe实例进行内存分配。<br>虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常。<br>真正申请分配内存的方法是unsafe.allocateMemory（）。<br><strong><br>代码2-9-使用unsafe分配本机内存：</strong></p><pre><code class="java"><span class="comment">/** *VM Args:-Xmx20M-XX:MaxDirectMemorySize=10M *<span class="doctag">@author</span> zzm */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span></span>{    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> int_1MB=<span class="number">1024</span>*<span class="number">1024</span>;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span><span class="keyword">throws</span> Exception</span>{        Field unsafeField=Unsafe.class.getDeclaredFields()[<span class="number">0</span>];        unsafeField.setAccessible(<span class="keyword">true</span>);        Unsafe unsafe=(Unsafe)unsafeField.get(<span class="keyword">null</span>);        <span class="keyword">while</span>(<span class="keyword">true</span>){            unsafe.allocateMemory(_1MB);        }    }}</code></pre><p><strong>运行结果：</strong></p><pre><code class="java">Exception in thread<span class="string">"main"</span>java.lang.OutOfMemoryError    at sun.misc.Unsafe.allocateMemory(Native Method)    at org.fenixsoft.oom.DMOOM.main(DMOOM.java：<span class="number">20</span>)</code></pre><p>由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果我们发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。  </p><p>本文内容来自书籍：</p><blockquote><p>深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《深入理解Java虚拟机》第二章阅读笔记&lt;br&gt;笔记基本只作为记录。&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://gracee.xin/tags/java/"/>
    
      <category term="jvm" scheme="http://gracee.xin/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>TCP的三次握手与四次挥手</title>
    <link href="http://gracee.xin/2018/01/05/wangluomianshi1/"/>
    <id>http://gracee.xin/2018/01/05/wangluomianshi1/</id>
    <published>2018-01-05T02:38:00.000Z</published>
    <updated>2018-03-28T09:54:55.492Z</updated>
    
    <content type="html"><![CDATA[<h5 id="三次握手（TCP的连接建立）"><a href="#三次握手（TCP的连接建立）" class="headerlink" title="三次握手（TCP的连接建立）"></a>三次握手（TCP的连接建立）</h5><p><img src="/images/network1.jpg" width="75%" height="75%"><br><a id="more"></a></p><p>0.一开始，客户端A和服务器B都是关闭(CLOSED)状态。<br>A主动打开连接，而B被动打开连接，进入监听(LISTEN)状态。  </p><p>1.<strong>A向B发送连接请求报文段</strong>：将报文段的同步位SYN置为1，并选择一个初始序号seq=x。然后A会进入“同步已发送(SYN-SEND)”状态。<br><strong>(SYN=1的报文段不能携带数据，但会消耗一个序号)</strong>  </p><p>2.B收到连接请求报文段后，如果同意连接，<strong>B会向A发送确认报文段</strong>：将同步位SYN置1，确认位ACK置1，确认号ack=x+1，同时选择一个初始序号seq=y。然后B会进入“同步已接收(SYN-RCVD)”状态。<br><strong>(这个报文段同样要消耗一个序号)</strong>  </p><p>3.A收到B的确认后，还需要向B给出确认。<strong>A向B发送确认报文段</strong>，报文段的ACK位置1，确认号ack=y+1，自己的序号seq=x+1(前面消耗了一个序号)。然后A会进入“已建立连接”状态。B收到确认后，也会进入“已建立连接”状态。<br><strong>(TCP规定ACK报文段可以携带数据，但如果不携带数据，则不消耗序号，所以这里没有携带数据的话，下一个A发出的数据报文段的序号seq=x+1)</strong><br>这时，连接建立完成。</p><ul><li>ASK：为什么要进行第三次握手（A为什么还要发送一次确认）？</li><li>ANSWER：这是为了防止“已失效的连接请求报文段突然传送到B”。假如第一次A发出的连接请求报文段中途在某些网络节点滞留(并未丢失)，在长时间未接收到B的确认报文后，A会进行重传。假设重传的报文段顺利到达B，与B完成了连接。这时，B收到了A的第一次请求报文，以为是A的一次新的请求，B会再次A发送确认报文，同意建立连接。如果没有第三次握手（A的再一次确认），新的连接(无用的)就会建立，这样会白白浪费B的资源。而有第三次握手，A对于B的确认会不予回应，这时B由于收不到A的再次确认，就知道A并没有要求连接了，连接也就不会建立。</li></ul><h5 id="四次挥手-握手-分手（TCP的连接释放）"><a href="#四次挥手-握手-分手（TCP的连接释放）" class="headerlink" title="四次挥手/握手/分手（TCP的连接释放）"></a>四次挥手/握手/分手（TCP的连接释放）</h5><p><img src="/images/network2.jpg" width="75%" height="75%">        </p><p>0.客户端A和服务器端B都为已连接(ESTABLISHED)状态。  </p><p>1.<strong>A向B发出连接释放报文段</strong>，主动关闭TCP连接：将报文段首部的终止位FIN置为1，<strong>seq=u</strong>（假设上一次A传送的数据报的最后一个字节的序号+1=u）。然后A进入终止等待1(FIN-WAIT-1)状态。 (携带FIN=1的报文段会消耗一个序号)  </p><p>2.B收到A发出的连接释放报文段后:<br>==&gt;<strong>需向A发送确认报文</strong>：ACK确认位置1，确认号ack=u+1，<strong>seq=v</strong>（假设上一次B传送的数据报的最后一个字节的序号+1=v）。<br>==&gt;TCP服务器进程向高层应用进程通知：A-&gt;B的TCP连接释放，TCP处于半关闭状态。A不会再向B发送数据，但B可以向A发送数据，且A仍要接收。<br>然后：B进入等待关闭(WAIT-CLOSED)状态。  </p><p>3.A收到B的确认报文后，进入终止等待2(FIN-WAIT-2)状态：等待B的释放连接报文。   </p><p>4.当B已经没有数据要向A发送了:<br>==&gt;应用进程向TCP服务器进程通知：B已经无数据发送，请释放TCP连接。B被动释放连接。<br>==&gt;<strong>B向A发送释放连接报文段</strong>：将FIN位置1，seq-w(B可能又向A发送了数据，设上一次发送数据最后一个字节序号+1=w)；重发ACK=1，ack=u+1。  然后B进入最后确认(LAST-ACK)状态。  </p><p>5.收到B的连接释放报文段后，<strong>A需要向B发出确认</strong>：ACK=1,确认号ack=w+1，序号seq=u+1(上一次A发出连接释放报文段时占用了一个序号)。A进入等待(TIME-WAIT)状态，需要等待2*MSL(最长报文段生命)的时间。  </p><p>6.B收到A的确认报文后，先进入关闭(CLOSED)状态；<br>  A在2MSL时间后，也进入关闭(CLOSED)状态。  </p><ul><li>ASK：为什么A必须等待2MSL时间？</li><li>ANSWER：<br>（1）为了确保A-&gt;B最后发送的ACK报文段能够到达。假设该A向B发送ACK报文段后就立即进入CLOSED状态，而ACK报文段未顺利到达B，在超时未收到A的ACK报文段时，B会重发前面的连接释放报文段，而这时A已经关闭了，这样会导致B无法顺便关闭。<br>（2）防止 “已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;三次握手（TCP的连接建立）&quot;&gt;&lt;a href=&quot;#三次握手（TCP的连接建立）&quot; class=&quot;headerlink&quot; title=&quot;三次握手（TCP的连接建立）&quot;&gt;&lt;/a&gt;三次握手（TCP的连接建立）&lt;/h5&gt;&lt;p&gt;&lt;img src=&quot;/images/network1.jpg&quot; width=&quot;75%&quot; height=&quot;75%&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="interview" scheme="http://gracee.xin/tags/interview/"/>
    
      <category term="TCP" scheme="http://gracee.xin/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>java实现二叉树的创建与四种遍历的递归/非递归</title>
    <link href="http://gracee.xin/2017/12/01/BinaryTree1/"/>
    <id>http://gracee.xin/2017/12/01/BinaryTree1/</id>
    <published>2017-12-01T13:59:00.000Z</published>
    <updated>2018-03-28T09:55:28.955Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树的内容只有在本科进行“数据结构”课程时学习过。二叉树是一种比较特别的数据结构，大多数算法都能用递归去做。 </p><p>在对二叉树进行前序、中序、后序及层次遍历时，递归是最简洁的方法，然而递归的性能一般都是比较低的，所以我们需要考虑用非递归（循环）的方式来实现几种遍历。<br><a id="more"></a></p><p>其中，后序遍历的非递归方法是来自这篇文章：<br><a href="http://www.jianshu.com/p/49c8cfd07410" target="_blank" rel="external">http://www.jianshu.com/p/49c8cfd07410</a><br>这篇文章实现递归遍历二叉树的代码非常整齐，值得学习。  </p><p>话不多说，上代码。  </p><p><strong><em>TreeNode.java</em></strong>  </p><pre><code class="java"><span class="comment">/** * Created by Gracee on 2017/11/27. * http://gracee.xin/ */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>{    <span class="keyword">public</span> <span class="keyword">int</span> val = <span class="number">0</span>;    <span class="keyword">public</span> TreeNode left = <span class="keyword">null</span>;    <span class="keyword">public</span> TreeNode right = <span class="keyword">null</span>;    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{        <span class="keyword">this</span>.val = val;    }}</code></pre><p><strong><em>treeOper.java</em></strong>  </p><pre><code class="java"><span class="keyword">import</span> java.util.LinkedList;<span class="keyword">import</span> java.util.Queue;<span class="keyword">import</span> java.util.Stack;<span class="comment">/** * Created by Gracee on 2017/11/27. * http://gracee.xin/ */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">treeOper</span></span>{    <span class="comment">//创建二叉树：输入数组，其中-1代表null；返回根节点</span>    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">createTree</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>{        <span class="keyword">int</span> length=array.length;        TreeNode tree[]=<span class="keyword">new</span> TreeNode[length];        <span class="keyword">int</span> i=<span class="number">0</span>;        <span class="keyword">while</span>(i&lt;length){            <span class="keyword">if</span>(array[i]!=-<span class="number">1</span>)                tree[i]=<span class="keyword">new</span> TreeNode(array[i]);            i++;        }        <span class="keyword">int</span> j=<span class="number">0</span>;        <span class="keyword">while</span>(j&lt;length){            <span class="keyword">if</span>(tree[j]==<span class="keyword">null</span>){                j++;                <span class="keyword">continue</span>;            }            <span class="keyword">if</span>(<span class="number">2</span>*j+<span class="number">1</span>&lt;length)                tree[j].left=tree[<span class="number">2</span>*j+<span class="number">1</span>];            <span class="keyword">if</span>(<span class="number">2</span>*j+<span class="number">2</span>&lt;length)                tree[j].right=tree[<span class="number">2</span>*j+<span class="number">2</span>];            j++;        }        <span class="keyword">return</span> tree[<span class="number">0</span>];    }    <span class="comment">//按层打印二叉树</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTree2</span><span class="params">(TreeNode root)</span></span>{        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();        <span class="keyword">if</span>(root!=<span class="keyword">null</span>) queue.add(root);        <span class="keyword">int</span> nextLevel=<span class="number">0</span>;        <span class="keyword">int</span> toBePrinted=<span class="number">1</span>;        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>){            root=queue.poll();            toBePrinted--;            System.out.print(root.val+<span class="string">" "</span>);            <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>){                queue.add(root.left);                nextLevel++;            }            <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>){                queue.add(root.right);                nextLevel++;            }            <span class="keyword">if</span>(toBePrinted==<span class="number">0</span>){                System.out.println();                toBePrinted=nextLevel;                nextLevel=<span class="number">0</span>;            }        }    }    <span class="comment">//求二叉树深度</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span> </span>{        <span class="keyword">if</span> (root==<span class="keyword">null</span>) {            <span class="keyword">return</span> <span class="number">0</span>;        }        <span class="keyword">int</span> l=depth(root.left);        <span class="keyword">int</span> r=depth(root.right);        <span class="keyword">return</span> l&gt;r?l+<span class="number">1</span>:r+<span class="number">1</span>;    }    <span class="comment">//二叉树的前序、中序、后序、层次遍历；递归+非递归方法</span>    <span class="comment">//前序递归遍历</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderRecur</span><span class="params">(TreeNode root)</span></span>{        <span class="keyword">if</span>(root!=<span class="keyword">null</span>){            System.out.print(root.val+<span class="string">" "</span>);            preOrderRecur(root.left);            preOrderRecur(root.right);        }    }    <span class="comment">//前序非递归遍历</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderLoop</span><span class="params">(TreeNode root)</span></span>{        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();        <span class="keyword">while</span>(root!=<span class="keyword">null</span>||!stack.empty()){            <span class="keyword">while</span>(root!=<span class="keyword">null</span>){                System.out.print(root.val+<span class="string">" "</span>);                stack.push(root);                root=root.left;            }            <span class="keyword">if</span>(!stack.empty()){                root=stack.pop();                root=root.right;            }        }    }    <span class="comment">//中序递归遍历</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrderRecur</span><span class="params">(TreeNode root)</span></span>{        <span class="keyword">if</span>(root!=<span class="keyword">null</span>){            preOrderRecur(root.left);            System.out.print(root.val+<span class="string">" "</span>);            preOrderRecur(root.right);        }    }    <span class="comment">//中序非递归遍历</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrderLoop</span><span class="params">(TreeNode root)</span></span>{        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();        <span class="keyword">while</span>(root!=<span class="keyword">null</span>||!stack.empty()){            <span class="keyword">while</span>(root!=<span class="keyword">null</span>){                stack.push(root);                root=root.left;            }            <span class="keyword">if</span>(!stack.empty()){                root=stack.pop();                System.out.print(root.val+<span class="string">" "</span>);                root=root.right;            }        }    }    <span class="comment">//后序递归遍历</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">posOrderRecur</span><span class="params">(TreeNode root)</span></span>{        <span class="keyword">if</span>(root!=<span class="keyword">null</span>){            preOrderRecur(root.left);            preOrderRecur(root.right);            System.out.print(root.val+<span class="string">" "</span>);        }    }    <span class="comment">//后序非递归遍历</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">posOrderLoop</span><span class="params">(TreeNode root)</span></span>{        Stack&lt;TreeNode&gt; stack1=<span class="keyword">new</span> Stack&lt;&gt;();        Stack&lt;Boolean&gt; stack2=<span class="keyword">new</span> Stack&lt;&gt;();        <span class="keyword">boolean</span> visited;        stack1.push(root);stack2.push(<span class="keyword">false</span>);        <span class="keyword">while</span>(!stack1.empty()&amp;&amp;!stack2.empty()){            root=stack1.pop();visited=stack2.pop();            <span class="keyword">if</span>(root==<span class="keyword">null</span>)                <span class="keyword">continue</span>;            <span class="keyword">if</span>(visited==<span class="keyword">true</span>){                System.out.print(root.val+<span class="string">" "</span>);            }            <span class="keyword">else</span> {                stack1.push(root);stack2.push(<span class="keyword">true</span>);                stack1.push(root.right);stack2.push(<span class="keyword">false</span>);                stack1.push(root.left);stack2.push(<span class="keyword">false</span>);            }        }    }    <span class="comment">//层次递归遍历</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrderRecur</span><span class="params">(TreeNode root)</span> </span>{        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span>;        <span class="keyword">int</span> depth=depth(root);        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=depth;i++) {            levelOrder(root, i);        }    }    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode root, <span class="keyword">int</span> level)</span> </span>{        <span class="keyword">if</span>(root==<span class="keyword">null</span>||level&lt;<span class="number">1</span>) <span class="keyword">return</span>;        <span class="keyword">if</span>(level==<span class="number">1</span>) {            System.out.print(root.val+<span class="string">" "</span>);            <span class="keyword">return</span>;        }        levelOrder(root.left,level-<span class="number">1</span>);        levelOrder(root.right,level-<span class="number">1</span>);    }    <span class="comment">//层次非递归遍历</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrderLoop</span><span class="params">(TreeNode root)</span></span>{        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();        <span class="keyword">if</span>(root!=<span class="keyword">null</span>) queue.add(root);        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>){            root= queue.poll();            System.out.print(root.val+<span class="string">" "</span>);            <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>) queue.add(root.left);            <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>) queue.add(root.right);        }    }    <span class="comment">//主方法，test</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{        treeOper op=<span class="keyword">new</span> treeOper();        <span class="keyword">int</span> array[]={<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">5</span>};        TreeNode root=op.createTree(array);        System.out.println(<span class="string">"创建的树："</span>);        op.printTree(root);        System.out.println(<span class="string">"二叉树深度："</span>);        System.out.print(op.depth(root));        System.out.println(<span class="string">"\n前序递归遍历："</span>);        op.preOrderRecur(root);        System.out.println(<span class="string">"\n前序非递归遍历："</span>);        op.preOrderLoop(root);        System.out.println(<span class="string">"\n中序递归遍历："</span>);        op.midOrderRecur(root);        System.out.println(<span class="string">"\n中序非递归遍历："</span>);        op.midOrderLoop(root);        System.out.println(<span class="string">"\n后序递归遍历："</span>);        op.posOrderRecur(root);        System.out.println(<span class="string">"\n后序非递归遍历："</span>);        op.posOrderLoop(root);        System.out.println(<span class="string">"\n层次递归遍历："</span>);        op.levelOrderRecur(root);        System.out.println(<span class="string">"\n层次非递归遍历："</span>);        op.levelOrderLoop(root);    }}</code></pre><p><strong>运行结果：</strong>  </p><pre><code class="shell">创建的树：7 6 4 2 5 8 5 二叉树深度：4前序递归遍历：7 6 2 5 4 5 8 前序非递归遍历：7 6 2 5 4 5 8 中序递归遍历：6 2 5 7 4 5 8 中序非递归遍历：6 5 2 7 5 4 8 后序递归遍历：6 2 5 4 5 8 7 后序非递归遍历：5 2 6 5 8 4 7 层次递归遍历：7 6 4 2 5 8 5 层次非递归遍历：7 6 4 2 5 8 5 Process finished with exit code 0</code></pre><p>附上主要参考的两篇博客，感谢~</p><blockquote><p><a href="http://www.jianshu.com/p/49c8cfd07410" target="_blank" rel="external">http://www.jianshu.com/p/49c8cfd07410</a><br><a href="https://www.cnblogs.com/liuyang0/p/6271324.html" target="_blank" rel="external">https://www.cnblogs.com/liuyang0/p/6271324.html</a>  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二叉树的内容只有在本科进行“数据结构”课程时学习过。二叉树是一种比较特别的数据结构，大多数算法都能用递归去做。 &lt;/p&gt;
&lt;p&gt;在对二叉树进行前序、中序、后序及层次遍历时，递归是最简洁的方法，然而递归的性能一般都是比较低的，所以我们需要考虑用非递归（循环）的方式来实现几种遍历。&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://gracee.xin/tags/java/"/>
    
      <category term="tree" scheme="http://gracee.xin/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu16.04+cuda8.0+cudnn6+tensorflow(gpu)1.4，一遍成功</title>
    <link href="http://gracee.xin/2017/11/28/tensorflowinstall/"/>
    <id>http://gracee.xin/2017/11/28/tensorflowinstall/</id>
    <published>2017-11-28T14:00:00.000Z</published>
    <updated>2018-03-28T09:54:59.186Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0-python环境（ubuntu16-04自带2-7-12"><a href="#0-python环境（ubuntu16-04自带2-7-12" class="headerlink" title="0 python环境（ubuntu16.04自带2.7.12)"></a>0 python环境（ubuntu16.04自带2.7.12)</h4><h6 id="0-1-查看python版本与安装路径"><a href="#0-1-查看python版本与安装路径" class="headerlink" title="0.1 查看python版本与安装路径"></a>0.1 查看python版本与安装路径</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> python --version  </div><div class="line">Python 2.7.12  </div><div class="line"><span class="meta">$</span> which python  </div><div class="line">/usr/bin/python</div></pre></td></tr></table></figure><a id="more"></a><h6 id="0-2-安装pip"><a href="#0-2-安装pip" class="headerlink" title="0.2 安装pip"></a>0.2 安装pip</h6><p>直接键入pip，会提示pip未安装，并给出安装命令，按命令执行即可。执行安装命令后，再升级pip。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> apt-get update</div><div class="line"><span class="meta">$</span> pip  </div><div class="line">The program 'pip' is currently not installed. You can install it by typing:  </div><div class="line">apt install python-pip  </div><div class="line"><span class="meta">$</span> apt install python-pip</div><div class="line"><span class="meta">$</span> python -m pip install -U pip</div></pre></td></tr></table></figure><h4 id="1-gcc版本降级"><a href="#1-gcc版本降级" class="headerlink" title="1 gcc版本降级"></a>1 gcc版本降级</h4><p>由于cuda8.0不支持ubuntu16.04自带的gcc5.4.0，所以要降级到4.9  </p><h6 id="1-1-查看gcc版本"><a href="#1-1-查看gcc版本" class="headerlink" title="1.1 查看gcc版本"></a>1.1 查看gcc版本</h6><pre><code>$ gcc --versiongcc (Ubuntu 5.4.0-6ubuntu1~16.04.5) 5.4.0 20160609  Copyright (C) 2015 Free Software Foundation, Inc.</code></pre><h6 id="1-2-降级操作"><a href="#1-2-降级操作" class="headerlink" title="1.2 降级操作"></a>1.2 降级操作</h6><pre><code class="shell"><span class="meta">$</span> sudo apt-get install g++-4.9  <span class="meta">$</span> sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.9 20  <span class="meta">$</span> sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 10  <span class="meta">$</span> sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.9 20  <span class="meta">$</span> sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-5 10  <span class="meta">$</span> sudo update-alternatives --install /usr/bin/cc cc /usr/bin/gcc 30  <span class="meta">$</span> sudo update-alternatives --set cc /usr/bin/gcc  <span class="meta">$</span> sudo update-alternatives --install /usr/bin/c++ c++ /usr/bin/g++ 30  <span class="meta">$</span> sudo update-alternatives --set c++ /usr/bin/g++</code></pre><h6 id="1-3-再次查看版本"><a href="#1-3-再次查看版本" class="headerlink" title="1.3 再次查看版本"></a>1.3 再次查看版本</h6><pre><code class="shell"><span class="meta">$</span> gcc --versiongcc (Ubuntu 4.9.3-13ubuntu2) 4.9.3Copyright (C) 2015 Free Software Foundation, Inc.</code></pre><h4 id="2-cuda8-0安装"><a href="#2-cuda8-0安装" class="headerlink" title="2 cuda8.0安装"></a>2 cuda8.0安装</h4><p>cuda安装的步骤主要来源于以下链接，博主写的流程很清晰，一遍过！<br><a href="http://www.jianshu.com/p/35c7fde85968?from=singlemessage" target="_blank" rel="external">http://www.jianshu.com/p/35c7fde85968?from=singlemessage</a> </p><h6 id="2-1-验证"><a href="#2-1-验证" class="headerlink" title="2.1 验证"></a>2.1 验证</h6><p><strong>2.1.1 Verify you have a CUDA-Capable GPU  </strong></p><pre><code class="shell"><span class="meta">$</span> lspci | grep -i nvidia  04:00.0 3D controller: NVIDIA Corporation GK110BGL [Tesla K40m] (rev a1)</code></pre><p><strong>2.1.2 Verify you have a Supported Version of Linux  </strong></p><pre><code class="shell"><span class="meta">$</span> uname -m &amp;&amp; cat /etc/*releasex86_64  DISTRIB_ID=Ubuntu  DISTRIB_RELEASE=16.04  ...</code></pre><p><strong>2.1.3 Verify the System Has GCC Installed  </strong><br>安装对应的kernels header和开发包： </p><pre><code class="shell"><span class="meta">$</span> sudo apt-get install linux-headers-$(uname -r)</code></pre><h6 id="2-2-下载cuda"><a href="#2-2-下载cuda" class="headerlink" title="2.2 下载cuda"></a>2.2 下载cuda</h6><p>地址：<a href="https://developer.nvidia.com/cuda-toolkit-archive" target="_blank" rel="external">https://developer.nvidia.com/cuda-toolkit-archive</a><br>选择需要的版本，这里我选择8.0，下载对应的runfile(cuda_8.0.44_linux.run)。<br>（下载还要注册、填一堆问卷也是醉了…….）<br>为了方便其他人，将我下载好的run文件的百度云链接放上。<br>链接：<a href="https://pan.baidu.com/s/1jIQUE0I" target="_blank" rel="external">https://pan.baidu.com/s/1jIQUE0I</a>  密码：rma8<br>下载完后，用MD5检验，如果序号不和，得重新下载。  </p><pre><code class="shell"><span class="meta">$</span> md5sum cuda_8.0.44_linux.run5639ffeb939ee58a81554d06bd084e15  cuda_8.0.44_linux.run</code></pre><h6 id="2-3-禁用Nouveau"><a href="#2-3-禁用Nouveau" class="headerlink" title="2.3 禁用Nouveau"></a>2.3 禁用Nouveau</h6><pre><code class="shell"><span class="meta">$</span> lsmod | grep nouveau</code></pre><p>如果有内容输出，则需要禁掉nouveau  </p><pre><code class="shell"><span class="meta">$</span> sudo vi /etc/modprobe.d/blacklist.conf</code></pre><p>添加如下内容： </p><pre><code class="shell">blacklist nouveau  options nouveau modeset=0</code></pre><p>保存退出(:wq)，再执行：  </p><pre><code class="shell"><span class="meta">$</span> sudo update-initramfs -u<span class="meta">$</span> sudo reboot</code></pre><p>重启后：  </p><pre><code class="shell"><span class="meta">$</span> lsmod | grep nouveau</code></pre><p>若无内容输出，则禁用成功。  </p><h6 id="2-4-安装"><a href="#2-4-安装" class="headerlink" title="2.4 安装"></a>2.4 安装</h6><p>切换到cuda_8.0.44_linux.run的目录，执行：  </p><pre><code class="shell"><span class="meta">$</span> sudo sh cuda_8.0.44_linux.run</code></pre><p>安装的时候，要让你先看一堆文字（EULA)，我们直接不停的按空格键到100%;<br>遇到提示是否安装openGL，选择no,其他的可以一路accept, yes或回车。<br>如图：<br><img src="/images/tensorflow1.png" alt=""><br>安装成功后，会显示installed，否则会显示failed。  </p><h6 id="2-5-验证安装结果"><a href="#2-5-验证安装结果" class="headerlink" title="2.5 验证安装结果"></a>2.5 验证安装结果</h6><p>执行  </p><pre><code class="shell"><span class="meta">$</span> ls /dev/nvidia*</code></pre><p>若结果显示  </p><pre><code class="shell">/dev/nvidia0  /dev/nvidiactl  /dev/nvidia-uvm</code></pre><p>或类似的信息，应该有三个（包含一个类似/dev/nvidia-nvm的），则安装成功。<br>但我的没有显示以上信息，显示的是：  </p><pre><code class="shell">ls: cannot access /dev/nvidia*: No such file or directory</code></pre><p>下面就要解决这个问题。<br>把下面的.sh文件随便命个名(我命名为Nka.sh)  </p><pre><code class="python"><span class="comment">#!/bin/bash</span>/sbin/modprobe nvidia<span class="keyword">if</span> [ <span class="string">"$?"</span> -eq <span class="number">0</span> ]; then  <span class="comment"># Count the number of NVIDIA controllers found.</span>  NVDEVS=`lspci | grep -i NVIDIA`  N3D=`echo <span class="string">"$NVDEVS"</span> | grep <span class="string">"3D controller"</span> | wc -l`  NVGA=`echo <span class="string">"$NVDEVS"</span> | grep <span class="string">"VGA compatible controller"</span> | wc -l`  N=`expr $N3D + $NVGA - <span class="number">1</span>`  <span class="keyword">for</span> i <span class="keyword">in</span> `seq <span class="number">0</span> $N`; do    mknod -m <span class="number">666</span> /dev/nvidia$i c <span class="number">195</span> $i  done  mknod -m <span class="number">666</span> /dev/nvidiactl c <span class="number">195</span> <span class="number">255</span><span class="keyword">else</span>  exit <span class="number">1</span>fi/sbin/modprobe nvidia-uvm<span class="keyword">if</span> [ <span class="string">"$?"</span> -eq <span class="number">0</span> ]; then  <span class="comment"># Find out the major device number used by the nvidia-uvm driver</span>  D=`grep nvidia-uvm /proc/devices | awk <span class="string">'{print $1}'</span>`  mknod -m <span class="number">666</span> /dev/nvidia-uvm c $D <span class="number">0</span><span class="keyword">else</span>  exit <span class="number">1</span>fi</code></pre><p>然后执行：  </p><pre><code class="shell"><span class="meta">$</span> sudo chmod +x Nka.sh<span class="meta">$</span> sudo ./Nka.sh<span class="meta">$</span>  ls /dev/nvidia*/dev/nvidia0  /dev/nvidiactl  /dev/nvidia-uvm</code></pre><p>成功！<br>but：<br>这种做不太友好，因为当下次重启电脑时，你使用ls /dev/nvidia* 指令时，你是看不到那三个nvidia的文件了。所以你又得手动执行sudo ./Nka.sh指令了。这个问题我们可以通过添加启动脚本来解决。<br>执行  </p><pre><code class="shell"><span class="meta">$</span> sudo vi /etc/rc.local</code></pre><p>如果你是第一次打开这个文件，它应该是空的(除了一行又一行的#注释项外)。<br>这文件的第一行是  </p><pre><code class="shell"><span class="meta">#</span>!/bin/sh -e</code></pre><p>把-e去掉（这步很重要，否则它不会加载这文本的内容）,<br>然后把Nka.sh的内容除了#!/bin/bash外复制到其中，(before exit 0 )保存退出。<br>下次重启时，你应该能直接看到/dev目录下的三个nvidia的文件。  </p><h6 id="2-6-环境配置"><a href="#2-6-环境配置" class="headerlink" title="2.6 环境配置"></a>2.6 环境配置</h6><p>打开系统配置文件  </p><pre><code class="shell"><span class="meta">$</span> sudo vi /etc/profile</code></pre><p>在文件最后添加  </p><pre><code class="shell">export PATH=/usr/local/cuda-8.0/bin:$PATHexport LD_LIBRARY_PATH=/usr/local/cuda-8.0/lib64:$LD_LIBRARY_PATH</code></pre><p>保存退出<br>执行下面的语句，让文件立即生效  </p><pre><code class="shell"><span class="meta">$</span> source /etc/profile</code></pre><p>至此，cuda 8.0安装完毕。</p><h6 id="2-7-验证安装"><a href="#2-7-验证安装" class="headerlink" title="2.7 验证安装"></a>2.7 验证安装</h6><p><strong>2.7.1 Verify the Driver Version</strong><br>敲入：  </p><pre><code class="shell"><span class="meta">$</span> cat /proc/driver/nvidia/version</code></pre><p>结果显示：  </p><pre><code class="shell">NVRM version: NVIDIA UNIX x86_64 Kernel Module  367.48  Sat Sep  3 18:21:08 PDT 2016GCC version:  gcc version 4.9.3 (Ubuntu 4.9.3-13ubuntu2)</code></pre><p><strong>2.7.2 Verify CUDA Toolkit</strong><br>敲入：  </p><pre><code class="shell"><span class="meta">$</span> nvcc -V</code></pre><p>结果显示：  </p><pre><code class="shell">nvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2016 NVIDIA CorporationBuilt on Sun_Sep__4_22:14:01_CDT_2016Cuda compilation tools, release 8.0, V8.0.44</code></pre><p><strong>2.7.3 Complie sample  </strong>  </p><pre><code class="shell"><span class="meta">$</span> cd /usr/local/cuda/samples/<span class="meta">$</span> make</code></pre><p>这区间大概需要十几到二十分钟，请耐心等待。<br>运行完后，编译结果会放在samples/bin下面。<br><strong>2.7.4 Running the Binaries  </strong>  </p><pre><code class="shell"><span class="meta">$</span> cd bin/x86_64/linux/release<span class="meta">$</span> ./deviceQuery</code></pre><p>结果显示：<br><img src="/images/tensorflow2.png" alt=""><br>最后是 Result = PASS,若失败 Result = FAIL<br>再来一个，执行  </p><pre><code class="shell"><span class="meta">$</span> ./bandwidthTest</code></pre><p>结果显示：<br><img src="/images/tensorflow3.png" alt="">  </p><h4 id="3-安装cudnn"><a href="#3-安装cudnn" class="headerlink" title="3 安装cudnn"></a>3 安装cudnn</h4><h6 id="3-1-下载Download-cuDNN-v6-0"><a href="#3-1-下载Download-cuDNN-v6-0" class="headerlink" title="3.1 下载Download cuDNN v6.0"></a>3.1 下载Download cuDNN v6.0</h6><p>cuDNN v6.0(Jan 20, 2017), for CUDA 8.0：<br><a href="https://developer.nvidia.com/rdp/cudnn-download" target="_blank" rel="external">https://developer.nvidia.com/rdp/cudnn-download</a><br>这里给出对应的百度云链接<br>链接：<a href="https://pan.baidu.com/s/1boSU4A7" target="_blank" rel="external">https://pan.baidu.com/s/1boSU4A7</a> 密码：73ck  </p><h6 id="3-2-安装："><a href="#3-2-安装：" class="headerlink" title="3.2 安装："></a>3.2 安装：</h6><pre><code class="shell"><span class="meta">$</span> tar -xzvf cudnn-8.0-linux-x64-v6.0.tgz<span class="meta">$</span> sudo cp cuda/include/cudnn.h /usr/local/cuda-8.0/include<span class="meta">$</span> sudo cp cuda/lib64/libcudnn* /usr/local/cuda-8.0/lib64<span class="meta">$</span> sudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda-8.0/lib64/libcudnn*<span class="meta">$</span> sudo ln -sf libcudnn.so.6.0.21 libcudnn.so.6  <span class="meta">$</span> sudo ln -sf libcudnn.so.6 libcudnn.so  <span class="meta">$</span> sudo ldconfig</code></pre><h4 id="4-安装tensorflow"><a href="#4-安装tensorflow" class="headerlink" title="4 安装tensorflow"></a>4 安装tensorflow</h4><h6 id="4-1-安装"><a href="#4-1-安装" class="headerlink" title="4.1 安装"></a>4.1 安装</h6><pre><code class="shell"><span class="meta">$</span> sudo apt-get install libcupti-dev<span class="meta">$</span> pip install tensorflow-gpu</code></pre><p>如果下载很慢或者出现问题，可能是因为国外源太慢，需要更改pip的源地址。<br>修改/root/.pip/pip.conf文件（没有则创建）。  </p><pre><code class="shell"><span class="meta">$</span> vim /root/.pip/pip.conf</code></pre><p>加入以下：  </p><pre><code class="shell">[global] index-url = http://pypi.douban.com/simple trusted-host = pypi.douban.com#没有这句会包warning disable-pip-version-check = true #版本不检查 timeout = 120#超时时间设置</code></pre><p>然后 esc,:wq保存退出。<br>重新执行：  </p><pre><code class="shell"><span class="meta">$</span> pip install tensorflow-gpu</code></pre><p>这里会安装一大堆东西，都是tensorflow需要的。如：  </p><pre><code class="shell">Successfully installed backports.weakref-1.0.post1 bleach-1.5.0 enum34-1.1.6 funcsigs-1.0.2 futures-3.1.1 html5lib-0.9999999 markdown-2.6.9 mock-2.0.0 numpy-1.13.3 pbr-3.1.1 protobuf-3.5.0.post1 six-1.11.0 tensorflow-gpu-1.4.0 tensorflow-tensorboard-0.4.0rc3 werkzeug-0.12.2</code></pre><h6 id="4-2-验证"><a href="#4-2-验证" class="headerlink" title="4.2 验证"></a>4.2 验证</h6><p>安装完成后，直接在命令行中试用，验证是否能成功使用。  </p><pre><code class="python">$ python&gt;&gt;&gt; import tensorflow as tf&gt;&gt;&gt; a=tf.constant(5.0)&gt;&gt;&gt; b=tf.constant(6.0)&gt;&gt;&gt; c=a*b&gt;&gt;&gt; sess=tf.Session()2017-11-28 21:20:40.953415: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1120] Creating TensorFlow device (/device:GPU:0) -&gt; (device: 0, name: Tesla K40m, pci bus id: 0000:04:00.0, compute capability: 3.5)&gt;&gt;&gt; print(sess.run(c))30.0&gt;&gt;&gt;</code></pre><p>如上即为安装成功，但也可能会出现一些问题。最常见的是  </p><pre><code class="shell">ImportError: libcudnn.so.6: cannot open shared object file: No such file or directory</code></pre><p>如果出现类似问题，可以先尝试：  </p><pre><code class="shell"><span class="meta">$</span> source /etc/profile</code></pre><p>如果还是没解决，可能就是你安装的cudnn版本和tensorflow的版本不能适应，之前我使用cudnn5.1的时候就是这种情况，tensorflow最新的版本1.4.0用不了。<br>你可以选择安装低版本的tensorflow：  </p><pre><code class="shell"><span class="meta">$</span> pip install tensorflow-gpu==1.2</code></pre><p>也可以换一个cudnn（换成提示语句中的cudnn6）。  </p><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h4><p>tensorflow for gpu的安装对于新手来说真的是大坑一个……  网上搜的教程，有一些是有帮助的，但也有很多特别乱的，看到最多的都是吐槽…….许多人装了一周两周的，十天半个月的都有，有的朋友重装几遍系统都没成功（默哀）。<br>我这里这个步骤，是我拿到新的机器（只有ubuntu16.04系统），然后一遍安装成功的，虽然时间也比较长，查了很多教程，但至少探索出目前这个ubuntu16.04+cuda8.0+cudnn6+tensorflow(gpu)1.4的版本对应，是可以成功的。<br>另，个人不建议用源码安装，非常繁杂并且很容易失败。  </p><p>最后附上参考的一些教程链接，感谢~</p><blockquote><p><a href="http://www.jianshu.com/p/35c7fde85968?from=singlemessage" target="_blank" rel="external">http://www.jianshu.com/p/35c7fde85968?from=singlemessage</a><br><a href="http://blog.csdn.net/dafenqie/article/details/78086390" target="_blank" rel="external">http://blog.csdn.net/dafenqie/article/details/78086390</a><br><a href="http://blog.csdn.net/selous/article/details/53309724" target="_blank" rel="external">http://blog.csdn.net/selous/article/details/53309724</a><br><a href="https://zhuanlan.zhihu.com/p/27890924" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/27890924</a><br><a href="https://www.tensorflow.org/install/install_linux" target="_blank" rel="external">https://www.tensorflow.org/install/install_linux</a>  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;0-python环境（ubuntu16-04自带2-7-12&quot;&gt;&lt;a href=&quot;#0-python环境（ubuntu16-04自带2-7-12&quot; class=&quot;headerlink&quot; title=&quot;0 python环境（ubuntu16.04自带2.7.12)&quot;&gt;&lt;/a&gt;0 python环境（ubuntu16.04自带2.7.12)&lt;/h4&gt;&lt;h6 id=&quot;0-1-查看python版本与安装路径&quot;&gt;&lt;a href=&quot;#0-1-查看python版本与安装路径&quot; class=&quot;headerlink&quot; title=&quot;0.1 查看python版本与安装路径&quot;&gt;&lt;/a&gt;0.1 查看python版本与安装路径&lt;/h6&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt; python --version  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Python 2.7.12  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt; which python  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;/usr/bin/python&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="tensorflow" scheme="http://gracee.xin/tags/tensorflow/"/>
    
      <category term="install" scheme="http://gracee.xin/tags/install/"/>
    
  </entry>
  
  <entry>
    <title>开启root账户的SSH登录</title>
    <link href="http://gracee.xin/2017/11/20/startRoot/"/>
    <id>http://gracee.xin/2017/11/20/startRoot/</id>
    <published>2017-11-20T14:30:00.000Z</published>
    <updated>2018-03-28T09:55:04.319Z</updated>
    
    <content type="html"><![CDATA[<p>由于我习惯用root账户了，实验室新来的服务器，给的一个用户名dell的登陆方式，当然是可以登录后切换的，但也设置一下允许直接使用root登录。<br>方法主要借鉴于：<br><a href="https://jingyan.baidu.com/article/d2b1d102abf7975c7f37d450.html" target="_blank" rel="external">https://jingyan.baidu.com/article/d2b1d102abf7975c7f37d450.html</a><br><a id="more"></a></p><h5 id="1-安装openssh："><a href="#1-安装openssh：" class="headerlink" title="1 安装openssh："></a>1 安装openssh：</h5><pre><code class="shell">xxx@ubuntu:~$ sudo apt-get install openssh-server</code></pre><h5 id="2-修改root密码"><a href="#2-修改root密码" class="headerlink" title="2 修改root密码"></a>2 修改root密码</h5><pre><code class="shell">xxx@ubuntu:~$ sudo passwd root</code></pre><h5 id="3-切换为root用户，修改config："><a href="#3-切换为root用户，修改config：" class="headerlink" title="3 切换为root用户，修改config："></a>3 切换为root用户，修改config：</h5><pre><code class="shell">xxx@ubuntu:~$ su - root   #切换到root账户Password:                 #输入第二步修改的root密码root@ubuntu:~# vim /etc/ssh/sshd_config</code></pre><p>找到下面这段代码，注释掉“PermitRootLogin prohibit-password”，添加“PermitRootLogin yes”  </p><pre><code class="shell"><span class="meta">#</span> Authentication: LoginGraceTime 120 <span class="meta">#</span>PermitRootLogin prohibit-passwordPermitRootLogin yes StrictModes yes</code></pre><h5 id="4-重启ssh服务"><a href="#4-重启ssh服务" class="headerlink" title="4 重启ssh服务"></a>4 重启ssh服务</h5><pre><code class="shell">root@ubuntu:~# sudo service ssh restart root@ubuntu:~#</code></pre><p>完毕，可以使用root账户直接ssh登录服务器</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于我习惯用root账户了，实验室新来的服务器，给的一个用户名dell的登陆方式，当然是可以登录后切换的，但也设置一下允许直接使用root登录。&lt;br&gt;方法主要借鉴于：&lt;br&gt;&lt;a href=&quot;https://jingyan.baidu.com/article/d2b1d102abf7975c7f37d450.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://jingyan.baidu.com/article/d2b1d102abf7975c7f37d450.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="install" scheme="http://gracee.xin/tags/install/"/>
    
  </entry>
  
  <entry>
    <title>java+tomcat+mysql环境配置</title>
    <link href="http://gracee.xin/2017/11/12/javatomcatmysqlsetup/"/>
    <id>http://gracee.xin/2017/11/12/javatomcatmysqlsetup/</id>
    <published>2017-11-12T13:22:00.000Z</published>
    <updated>2018-03-28T09:54:48.446Z</updated>
    
    <content type="html"><![CDATA[<p><code>趁还有学生优惠的时候，购了一年的阿里云服务器，记录一下基本javaweb的配置。</code>  </p><p>==<strong>系统：ubuntu1 16.04</strong>==<br><a id="more"></a></p><h5 id="1-java环境"><a href="#1-java环境" class="headerlink" title="1.java环境"></a>1.java环境</h5><p><strong>(1)在根目录下新建download和java文件夹</strong>  </p><pre><code class="shell"><span class="meta">$</span> mkdir /download<span class="meta">$</span> mkdir /usr/java</code></pre><p><strong>(2)下载jdk</strong>  </p><p>下载jdk至/download,jdk地址：<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a>  </p><p><strong>(3)将jdk解压至/usr/java</strong>  </p><pre><code class="shell"><span class="meta">$</span> cd /download<span class="meta">$</span> tar zxvf jdk-8u144-linux-x64.tar.gz -C /usr/java</code></pre><p>修改名称：  </p><pre><code class="shell"><span class="meta">$</span> mv jdk1.8.0_25 jdk1.8</code></pre><p><strong>(4)配置环境变量</strong></p><pre><code class="shell"><span class="meta">$</span> vim /etc/profile</code></pre><p>在文件末尾加入：  </p><pre><code class="shell"><span class="meta">$</span> export JAVA_HOME=/usr/java/jdk1.8 <span class="meta">$</span> export JRE_HOME=${JAVA_HOME}/jre<span class="meta">$</span> export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib  <span class="meta">$</span> export PATH=${JAVA_HOME}/bin:$PATH</code></pre><p>使环境变量生效：  </p><pre><code class="shell"><span class="meta">$</span> source /etc/profile</code></pre><p>查看java环境  </p><pre><code class="shell"><span class="meta">$</span> java -version</code></pre><h5 id="2-安装tomcat"><a href="#2-安装tomcat" class="headerlink" title="2.安装tomcat"></a>2.安装tomcat</h5><p><strong>(1)下载tomcat至/download</strong><br><a href="https://tomcat.apache.org/download-90.cgi" target="_blank" rel="external">https://tomcat.apache.org/download-90.cgi</a>  </p><p>解压至/usr/java:  </p><pre><code class="shell"><span class="meta">$</span> cd /download<span class="meta">$</span> tar zxvf apache-tomcat-9.0.1.tar.gz -C /usr/java</code></pre><p>修改名称：  </p><pre><code class="shell"><span class="meta">$</span> mv apache-tomcat-9.0.1 tomcat9</code></pre><p><strong>(2)配置环境变量</strong></p><pre><code class="shell"><span class="meta">$</span> vim /etc/profile</code></pre><p>在文件末尾加入：</p><pre><code class="shell"><span class="meta">$</span> export CATALINA_HOME=/usr/java/tomcat9</code></pre><p>使环境变量生效：  </p><pre><code class="shell"><span class="meta">$</span> source /etc/profile</code></pre><h5 id="3-启动tomcat"><a href="#3-启动tomcat" class="headerlink" title="(3)启动tomcat"></a>(3)启动tomcat</h5><pre><code class="shell"><span class="meta">$</span> cd /usr/java/tomcat9<span class="meta">$</span> ./bin/startup.sh</code></pre><p>打开浏览器：<a href="http://服务器ip:8080/" target="_blank" rel="external">http://服务器ip:8080/</a><br>可以看到如下界面：<br><img src="/images/tomcat1.png" alt="">  </p><h5 id="3-安装mysql"><a href="#3-安装mysql" class="headerlink" title="3.安装mysql"></a>3.安装mysql</h5><p><strong>(1)安装</strong>  </p><pre><code class="shell"><span class="meta">$</span> apt-get update<span class="meta">$</span> apt-get install mysql-server mysql-client libmysqlclient-dev</code></pre><p>在此安装过程中会让你输入root用户(管理MySQL数据库用户，非Linux系统用户)密码，按照要求输入即可。  </p><p><strong>(2)测试安装是否成功</strong>  </p><pre><code class="shell"><span class="meta">$</span> sudo netstat -tap | grep mysql<span class="meta">$</span> mysql -u root -p<span class="meta">$</span> service mysql start<span class="meta">$</span> service mysql stop<span class="meta">$</span> service mysql restart</code></pre><p><strong>(3)修改配置文件，方便远程连接</strong></p><pre><code class="shell"><span class="meta">$</span> vim /etc/mysql/mysql.conf.d/mysqld.cnf</code></pre><p>将“bind-address = 127.0.0.1”这一行注释掉。  </p><pre><code class="shell"><span class="meta">#</span>bind-address = 127.0.0.1</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;趁还有学生优惠的时候，购了一年的阿里云服务器，记录一下基本javaweb的配置。&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;==&lt;strong&gt;系统：ubuntu1 16.04&lt;/strong&gt;==&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://gracee.xin/tags/java/"/>
    
      <category term="install" scheme="http://gracee.xin/tags/install/"/>
    
      <category term="tomcat" scheme="http://gracee.xin/tags/tomcat/"/>
    
      <category term="mysql" scheme="http://gracee.xin/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>旋转数组的最小数字</title>
    <link href="http://gracee.xin/2017/11/09/minNumberInRotateArray/"/>
    <id>http://gracee.xin/2017/11/09/minNumberInRotateArray/</id>
    <published>2017-11-09T13:33:00.000Z</published>
    <updated>2018-03-28T09:55:21.989Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。<br><a id="more"></a></p><p><strong>方法1–顺序查找：</strong><br>顺序查找，直到找到第一个小于前面序列的数。代码十分简洁，但是效率较低。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">minofRotatearr</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(array[i]&lt;=array[i+<span class="number">1</span>])&#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(array[i]&gt;array[i+<span class="number">1</span>])&#123;</div><div class="line">            <span class="keyword">return</span> array[i+<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        minofRotatearr m =<span class="keyword">new</span> minofRotatearr();</div><div class="line">        <span class="keyword">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</div><div class="line">        System.out.println(m.minNumberInRotateArray(a));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>方法2–二分查找：</strong><br>由于旋转后的数组可以划分为两个排序子数组，前面子数组的元素都大于或等于后面子数组的元素，且最小的元素恰好能划分两个子数组。<br>类似二分查找，我们可以用两个指针p和q指向数组的第一个元素和最后一个元素；并且用一个指针mid指向数组中间的元素。如果mid指向的元素大于q指向的元素，说明最小的元素在mid和q之间；反之，最小元素应该在p和mid之间。<br>按照这种思路，如果最小的元素在mid和q之间，我们可以把移动指针p到mid的位置，继续查找；反之，将指针q移动到mid的位置上，直至p和q。<br>然后考虑三种特殊情况：<br>(1)有序的数组可以视为将前面的0个元素搬到最后的特殊旋转数组，这种情况可以在一开始做判断，如果数组的第一个元素小于最后一个元素，就直接返回第一个元素。<br>(2)p、q、mid指向的元素都相等。如：{3,4,0,3,3,3,3}，这时，我们无法判断mid指向的元素的属于前面的子数组还是后面的了。针对这种情况，只能采取顺序查找，返回找到最小的元素（方法1）<br>(3)数组长度小于等于零等边界情况。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">minInRotateArray</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> array[])</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> p=<span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> q=array.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> mid=<span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(array.length&lt;=<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(array[p]&lt;array[q])&#123;</div><div class="line">            <span class="keyword">return</span> array[p];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(q&gt;p+<span class="number">1</span>)&#123;</div><div class="line">            mid=(p+q)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(array[mid]==array[p]&amp;&amp;array[p]==array[q])&#123;</div><div class="line">                <span class="keyword">int</span> result=array[p];</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=p+<span class="number">1</span>;i&lt;q;i++)&#123;</div><div class="line">                    <span class="keyword">if</span>(array[i]&lt;result)</div><div class="line">                        result=array[i];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(array[mid]&gt;array[q])</div><div class="line">                p=mid;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                q=mid;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> array[p]&lt;array[q]?array[p]:array[q];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> array[]=&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</div><div class="line">        minInRotateArray test=<span class="keyword">new</span> minInRotateArray();</div><div class="line">        System.out.println(test.minNumberInRotateArray(array));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>记录和整理所做的工作是一种很重要的能力，这一个月忙于准备开题、组会，博客又很久忘更。<br>决定以后每周至少记录一次，无论内容，只为养成习惯。  </p><blockquote><p>参考书籍：《剑指offer》</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。&lt;br&gt;例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。&lt;br&gt;NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://gracee.xin/tags/java/"/>
    
      <category term="practice" scheme="http://gracee.xin/tags/practice/"/>
    
      <category term="moods" scheme="http://gracee.xin/tags/moods/"/>
    
  </entry>
  
  <entry>
    <title>redis-cli操作（命令）</title>
    <link href="http://gracee.xin/2017/09/04/rediscli%20command/"/>
    <id>http://gracee.xin/2017/09/04/rediscli command/</id>
    <published>2017-09-04T08:54:30.000Z</published>
    <updated>2018-03-28T09:55:08.444Z</updated>
    
    <content type="html"><![CDATA[<p>【转】</p><h4 id="一、入口"><a href="#一、入口" class="headerlink" title="一、入口"></a>一、入口</h4><p>redis安装后，在linux或windows里redis的安装路径<br>（如：src和/usr/local/bin；D:\Redis）下有几个以redis开头的可执行文件，称为redis shell，这些可执行文件可做很多事情。<br><a id="more"></a></p><table><thead><tr><th>可执行文件</th><th>作用</th></tr></thead><tbody><tr><td>redis-server</td><td>启动redis</td></tr><tr><td>redis-cli</td><td>redis命令行工具</td></tr><tr><td>redis-benchmark</td><td>基准测试工具</td></tr><tr><td>redis-check-aof</td><td>AOF持久化文件检测工具和修复工具</td></tr><tr><td>redis-check-dump</td><td>RDB持久化文件检测工具和修复工具</td></tr><tr><td>redis-sentinel</td><td>启动redis-sentinel  </td></tr></tbody></table><p>我们可以通过redis-cli来连接redis服务器，对其执行操作。<br>如：<br>$redis-cli -h 127.0.0.1 -p 6379<br>$redis-cli -h 192.168.0.248 -p 6379  </p><h4 id="二、redis命令"><a href="#二、redis命令" class="headerlink" title="二、redis命令"></a>二、redis命令</h4><p><strong>连接操作相关的命令</strong></p><p>默认直接连接  远程连接-h 192.168.1.20 -p 6379<br>ping：测试连接是否存活如果正常会返回pong<br>echo：打印<br>select：切换到指定的数据库，数据库索引号index 用数字值指定，以 0 作为起始索引值<br>quit：关闭连接（connection）<br>auth：简单密码认证</p><p><strong>服务端相关命令</strong></p><p>time：返回当前服务器时间<br>client list: 返回所有连接到服务器的客户端信息和统计数据  参见<a href="http://redisdoc.com/server/client_list.html" target="_blank" rel="external">http://redisdoc.com/server/client_list.html</a><br>client kill ip:port：关闭地址为 ip:port 的客户端<br>save：将数据同步保存到磁盘<br>bgsave：将数据异步保存到磁盘<br>lastsave：返回上次成功将数据保存到磁盘的Unix时戳<br>shundown：将数据同步保存到磁盘，然后关闭服务<br>info：提供服务器的信息和统计<br>config resetstat：重置info命令中的某些统计数据<br>config get：获取配置文件信息<br>config set：动态地调整 Redis 服务器的配置(configuration)而无须重启，可以修改的配置参数可以使用命令 CONFIG GET * 来列出<br>config rewrite：Redis 服务器时所指定的 redis.conf 文件进行改写<br>monitor：实时转储收到的请求<br>slaveof：改变复制策略设置</p><p><strong>对KEY操作的命令</strong>  </p><p>exists(key)：确认一个key是否存在<br>del(key)：删除一个key<br>type(key)：返回值的类型<br>keys(pattern)：返回满足给定pattern的所有key<br>randomkey：随机返回key空间的一个<br>keyrename(oldname, newname)：重命名key<br>dbsize：返回当前数据库中key的数目<br>expire：设定一个key的活动时间（s）<br>ttl：获得一个key的活动时间<br>move(key, dbindex)：移动当前数据库中的key到dbindex数据库<br>flushdb：删除当前选择数据库中的所有key<br>flushall：删除所有数据库中的所有key</p><p><strong>对String操作的命令</strong>  </p><p>set(key, value)：给数据库中名称为key的string赋予值value<br>get(key)：返回数据库中名称为key的string的value<br>getset(key, value)：给名称为key的string赋予上一次的value<br>mget(key1, key2,…, key N)：返回库中多个string的value<br>setnx(key, value)：添加string，名称为key，值为value<br>setex(key, time, value)：向库中添加string，设定过期时间time<br>mset(key N, value N)：批量设置多个string的值<br>msetnx(key N, value N)：如果所有名称为key i的string都不存在<br>incr(key)：名称为key的string增1操作<br>incrby(key, integer)：名称为key的string增加integer<br>decr(key)：名称为key的string减1操作<br>decrby(key, integer)：名称为key的string减少integer<br>append(key, value)：名称为key的string的值附加value<br>substr(key, start, end)：返回名称为key的string的value的子串</p><p><strong>对List操作的命令</strong></p><p>rpush(key, value)：在名称为key的list尾添加一个值为value的元素<br>lpush(key, value)：在名称为key的list头添加一个值为value的 元素<br>llen(key)：返回名称为key的list的长度<br>lrange(key, start, end)：返回名称为key的list中start至end之间的元素<br>ltrim(key, start, end)：截取名称为key的list<br>lindex(key, index)：返回名称为key的list中index位置的元素<br>lset(key, index, value)：给名称为key的list中index位置的元素赋值<br>lrem(key, count, value)：删除count个key的list中值为value的元素<br>lpop(key)：返回并删除名称为key的list中的首元素<br>rpop(key)：返回并删除名称为key的list中的尾元素<br>blpop(key1, key2,… key N, timeout)：lpop命令的block版本。<br>brpop(key1, key2,… key N, timeout)：rpop的block版本。<br>rpoplpush(srckey, dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部</p><p><strong>对Set操作的命令</strong></p><p>sadd(key, member)：向名称为key的set中添加元素member<br>srem(key, member) ：删除名称为key的set中的元素member<br>spop(key) ：随机返回并删除名称为key的set中一个元素<br>smove(srckey, dstkey, member) ：移到集合元素<br>scard(key) ：返回名称为key的set的基数<br>sismember(key, member) ：member是否是名称为key的set的元素<br>sinter(key1, key2,…key N) ：求交集<br>sinterstore(dstkey, (keys)) ：求交集并将交集保存到dstkey的集合<br>sunion(key1, (keys)) ：求并集<br>sunionstore(dstkey, (keys)) ：求并集并将并集保存到dstkey的集合<br>sdiff(key1, (keys)) ：求差集<br>sdiffstore(dstkey, (keys)) ：求差集并将差集保存到dstkey的集合<br>smembers(key) ：返回名称为key的set的所有元素<br>srandmember(key) ：随机返回名称为key的set的一个元素</p><p><strong>对Hash操作的命令</strong></p><p>hset(key, field, value)：向名称为key的hash中添加元素field<br>hget(key, field)：返回名称为key的hash中field对应的value<br>hmget(key, (fields))：返回名称为key的hash中field i对应的value<br>hmset(key, (fields))：向名称为key的hash中添加元素field<br>hincrby(key, field, integer)：将名称为key的hash中field的value增加integer<br>hexists(key, field)：名称为key的hash中是否存在键为field的域<br>hdel(key, field)：删除名称为key的hash中键为field的域<br>hlen(key)：返回名称为key的hash中元素个数<br>hkeys(key)：返回名称为key的hash中所有键<br>hvals(key)：返回名称为key的hash中所有键对应的value<br>hgetall(key)：返回名称为key的hash中所有的键（field）及其对应的value</p><p><img src="/images/jonyj.JPG" alt=""></p><blockquote><p>转自博客：<a href="http://www.cnblogs.com/kongzhongqijing/p/6867960.html" target="_blank" rel="external">http://www.cnblogs.com/kongzhongqijing/p/6867960.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【转】&lt;/p&gt;
&lt;h4 id=&quot;一、入口&quot;&gt;&lt;a href=&quot;#一、入口&quot; class=&quot;headerlink&quot; title=&quot;一、入口&quot;&gt;&lt;/a&gt;一、入口&lt;/h4&gt;&lt;p&gt;redis安装后，在linux或windows里redis的安装路径&lt;br&gt;（如：src和/usr/local/bin；D:\Redis）下有几个以redis开头的可执行文件，称为redis shell，这些可执行文件可做很多事情。&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://gracee.xin/tags/java/"/>
    
      <category term="moods" scheme="http://gracee.xin/tags/moods/"/>
    
      <category term="records" scheme="http://gracee.xin/tags/records/"/>
    
  </entry>
  
  <entry>
    <title>从尾到头打印链表</title>
    <link href="http://gracee.xin/2017/08/30/printListFromTailToHead/"/>
    <id>http://gracee.xin/2017/08/30/printListFromTailToHead/</id>
    <published>2017-08-30T09:10:14.000Z</published>
    <updated>2018-03-28T09:55:13.596Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表，从尾到头打印链表每个节点的值。  </p><p><strong>方法1–递归：</strong><br>反向输出链表=每访问到一个节点，先递归输出它后面的节点。<br><a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="comment">//链表结构定义</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    ListNode next= <span class="keyword">null</span>;</div><div class="line">    ListNode(<span class="keyword">int</span> val)&#123;</div><div class="line">        <span class="keyword">this</span>.val=val;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">ArrayList&lt;Integer&gt; arrayList=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(listNode!=<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">this</span>.printListFromTailToHead(listNode.next);</div><div class="line">            arrayList.add(listNode.val);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> arrayList;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//test[1,2]</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        ListNode Node=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</div><div class="line">        Node.next=<span class="keyword">new</span> ListNode(<span class="number">2</span>);</div><div class="line">        System.out.println(<span class="keyword">new</span> printReverseLinklist().printListFromTailToHead(Node));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>方法1–使用Stack：</strong><br>1.遍历链表，将每个节点入栈<br>2.从栈顶逐个弹出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"><span class="comment">//链表结构定义</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    ListNode next= <span class="keyword">null</span>;</div><div class="line">    ListNode(<span class="keyword">int</span> val)&#123;</div><div class="line">        <span class="keyword">this</span>.val=val;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">ArrayList&lt;Integer&gt; arrayList=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</div><div class="line">        Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;Integer&gt;();</div><div class="line">        ListNode p=listNode;</div><div class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</div><div class="line">            stack.push(p.val);<span class="comment">//遍历入栈</span></div><div class="line">            p=p.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(!stack.empty())&#123;</div><div class="line">            arrayList.add(stack.pop());<span class="comment">//出栈</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> arrayList;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//test[1,2]</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        ListNode Node=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</div><div class="line">        Node.next=<span class="keyword">new</span> ListNode(<span class="number">2</span>);</div><div class="line">        System.out.println(<span class="keyword">new</span> printReverseLinklist().printListFromTailToHead(Node));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="/images/sea2.JPG" alt=""></p><blockquote><p>参考书籍：《剑指offer》</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;输入一个链表，从尾到头打印链表每个节点的值。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法1–递归：&lt;/strong&gt;&lt;br&gt;反向输出链表=每访问到一个节点，先递归输出它后面的节点。&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://gracee.xin/tags/java/"/>
    
      <category term="practice" scheme="http://gracee.xin/tags/practice/"/>
    
      <category term="moods" scheme="http://gracee.xin/tags/moods/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO学习</title>
    <link href="http://gracee.xin/2017/07/14/NIO/"/>
    <id>http://gracee.xin/2017/07/14/NIO/</id>
    <published>2017-07-14T06:51:17.000Z</published>
    <updated>2018-03-28T09:55:17.692Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、为什么出现Java-NIO"><a href="#一、为什么出现Java-NIO" class="headerlink" title="一、为什么出现Java NIO"></a>一、为什么出现Java NIO</h4><p>由于Java的OutputStream和InputStream没有提供异步I/O的能力，OutputStream上的写操作write()方法会阻塞直至数据被成功写入，InputStream上的读操作read()方法也会阻塞，直到有数据可读，还有ServerSocket的accept()方法也会阻塞直至有客户端进行连接。它们都是阻塞方法，那当服务器需要处理上千个客户请求时，往往就需要一个客户对应一个线程，大量的闲置客户端会限制系统可以同时服务的客户端总数，所以JDK1.4引入了Java NIO(New Input/Output)。<br><a id="more"></a></p><h4 id="二、Java-NIO-基础"><a href="#二、Java-NIO-基础" class="headerlink" title="二、Java NIO 基础"></a>二、Java NIO 基础</h4><p>非阻塞：NIO引入了选择器（Selector）和通道（Channel）来实现非阻塞，通过表示到设备、文件、网络套接字这种可以执行不同I/O操作的程序组件的开放连接，有的通道允许选择器对它们进行轮询。通道可以注册一个选择器实例，通过该实例的select()方法来询问在一个或一组通道中，哪一个当前需要服务（读、写、接受）。非阻塞指的就是“在一个准备好的通道上进行相应的I/O操作，就不需要等待（阻塞）了”。    </p><p><strong>1.缓冲区</strong>     </p><p>NIO一个主要的特性就是java.nio.Buffer。缓冲区代表了一个有限容量的容器（本质是一个数组），通道Channel使用Buffer实例来传递数据。流和通道的主要区别就是通道在读写数据时，所有的内容都是先放入缓冲区之中，再通过缓冲区取得的，这也说明了为什么通道是双向操作的，而流是单向的。</p><p>缓冲区有几个比较重要的变量：position、limit、capacity等；</p><p>还有几个操作缓冲区常用的方法：allocate()、wrap()、get()、put()、flip()等；</p><p>这里先不对这些进行说明，先大概从方法名和变量名能有一定的理解。</p><p><strong>2.通道</strong></p><p>Channel实例代表一个和设备的连接，通过它可以进行输入输出操作。</p><p>Java NIO中，ServerSocketChannel和SocketChannel对应于传统的基本套接字ServerSocket和Socket。</p><p>（1）ServerSocketChannel和SocketChannel都通过工厂方法创建，就是常见的open()方法。SocketChannel创建后，可以通过connect()方法连接到远程机器，通过close()关闭连接，和原来的Socket的操作没什么差别。</p><p>（2）SocketChannel读写数据时和通过Socket获取输入输出流进行读写不同，它使用前面说的Buffer缓冲区作为参数。一般使用read()/write()及其扩展方法。ServerSocketChannel提供了和ServerSocket类似的accept()、close()方法；但不提供bind()方法，要实现绑定Socket到某端口，需要使用ServerSocket.socket().bind(…)方法。</p><p>（3）通过configureBlocking(false)方法可以可以把Channel设置为非阻塞式。非阻塞式SocketChannel和阻塞式Socket有一些不同，比如：非阻塞式SocketChannel的connect()方法会立即返回，用户必须通过isConnected()判断连接是否已经建立，或者通过finishConnect()方法在非阻塞套接字上阻塞等待连接成功；非阻塞的read()在Socket上没有数据时会立即返回（0），不会等待；非阻塞的accept()如果没有等待的连接，将立即返回null。</p><p>（4）ServerSocketChannel和SocketChannel能够跟选择器（Selector）配合工作，避免非阻塞式I/O操作中很浪费资源的忙等方法。例如在连接很多但需要处理的请求很少时，就需要一种方法阻塞等待，直到至少一个Channel可以进行I/O操作，并指出是哪个通道，选择器就是为了这个功能而设计：一个Selector实例可以同时检查（等待）一组通道的I/O方法。</p><p><strong>3.选择器</strong>  </p><p>选择器（Selector）创建实例后，通过Channel的注册方法注册到想要监控的Channel实例上，然后调用选择器的select()方法，该方法会阻塞等待，直到有一个或多个通道准备好I/O操作。select()方法会返回可进行I/O操作的通道数量。它使得一个线程就能检查多个通道是否可以进行I/O操作，而不是一个线程对应一个通道了。</p><p>这里很重要的一点是选择器和通道进行关联的SelectionKey（选择器注册标记），它维护了一个通道上感兴趣的事件类型信息，包括4种：OP<em> READ（通道上有数据可读）、OP</em> WRITE（通道上已经可写）、OP_ CONNECT（通道连接已建立）、OP_ACCEPT（通道上有连接请求）。</p><p>调用通道的register()方法，可以将一个选择器注册到通道，并指定该通道的初始兴趣时间集，注册完毕后便可以开始等待通道I/O事件了。</p><p>当select()方法的返回值大于0，表明有需要处理的I/O事件发生，选择器会将对应的通道放入已选键集中，通过Selector.selectedKeys()可以获得该集合，并在上面迭代处理关联通道上的I/O操作。比如通过selectedKeys()方法获取可进行I/O操作的通道，通过便利通道，利用SelectionKey判断通道上等待的操作（如key.isAcceptable()表明有一个入站请求），并做相应处理。</p><p>三、Java NIO 实例</p><p>下面一个demo用于更好地理解，实现的就是客户端向服务端的连接和互相发送当前时间。</p><ul><li>NIOyyjServer.java  </li></ul><pre><code class="java"><span class="keyword">package</span> com.yyj.nio;  <span class="keyword">import</span> java.net.InetSocketAddress;  <span class="keyword">import</span> java.net.ServerSocket;  <span class="keyword">import</span> java.nio.ByteBuffer;  <span class="keyword">import</span> java.nio.channels.SelectionKey;  <span class="keyword">import</span> java.nio.channels.Selector;  <span class="keyword">import</span> java.nio.channels.ServerSocketChannel;  <span class="keyword">import</span> java.nio.channels.SocketChannel;  <span class="keyword">import</span> java.util.Date;  <span class="keyword">import</span> java.util.Iterator;  <span class="comment">/**  * Created by GraceYang on 2017/4/6.  */</span>  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOyyjServer</span> </span>{      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span><span class="keyword">throws</span> Exception</span>{          ServerSocketChannel serverSocketChannel=ServerSocketChannel.open();<span class="comment">// 获得一个ServerSocket通道  </span>        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);<span class="comment">// 设置通道为非阻塞  </span>        ServerSocket serverSocket=serverSocketChannel.socket();<span class="comment">//获得该通道对应的ServerSocket  </span>        InetSocketAddress address=<span class="keyword">new</span> InetSocketAddress(<span class="number">8000</span>);          serverSocket.bind(address);<span class="comment">// 将该通道对应的ServerSocket绑定到8080端口  </span>        Selector selector=Selector.open();<span class="comment">// 获得一个通道管理器  </span>        <span class="comment">//将通道管理器和该通道绑定，并为该通道注册SelectionKey.OP_ACCEPT事件  </span>        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);          <span class="keyword">while</span>(<span class="keyword">true</span>){              <span class="comment">//注册OP_ACCEPT事件后：  </span>            <span class="comment">//当该事件到达时，selector.select()会返回，如果该事件没到达selector.select()会一直阻塞。  </span>            selector.select();              Iterator iterator=selector.selectedKeys().iterator();<span class="comment">// 获得selector中选中的项的迭代器，选中的项为注册的事件  </span>            <span class="keyword">while</span>(iterator.hasNext()){                  SelectionKey key=(SelectionKey) iterator.next();                  iterator.remove();<span class="comment">// 删除已选的key,以防重复处理  </span>                <span class="comment">// 客户端请求连接事件  </span>                <span class="keyword">if</span>(key.isAcceptable()){                      ServerSocketChannel serverSocketChannel1=(ServerSocketChannel)key.channel();                      SocketChannel socketChannel=serverSocketChannel1.accept();<span class="comment">// 获得和客户端连接的通道  </span>                    socketChannel.configureBlocking(<span class="keyword">false</span>);<span class="comment">// 设置成非阻塞  </span>                    Thread.sleep(<span class="number">3000</span>);                      <span class="comment">//给客户端发送信息当前时间  </span>                    socketChannel.write(ByteBuffer.wrap(<span class="keyword">new</span> String(<span class="string">"向客户端发送当前时间"</span>+<span class="keyword">new</span> Date()).getBytes()));                      <span class="comment">//在和客户端连接成功之后，为了可以接收到客户端的信息，需要给通道设置读的权限。  </span>                    socketChannel.register(selector, SelectionKey.OP_READ);                  }                  <span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()){<span class="comment">// 获得了可读的事件 ；处理读取客户端发来的信息的事件  </span>                    SocketChannel socketChannel=(SocketChannel)key.channel();<span class="comment">// 服务器可读取消息:得到事件发生的Socket通道  </span>                    ByteBuffer buf=ByteBuffer.allocate(<span class="number">100</span>);<span class="comment">// 创建读取的缓冲区  </span>                    socketChannel.read(buf);<span class="comment">//读取到了客户端发来的信息  </span>                    <span class="keyword">byte</span>[] data = buf.array();                      String msg = <span class="keyword">new</span> String(data).trim();                      System.out.println(<span class="string">"服务端收到信息："</span>+msg);                      socketChannel.close();                  }              }          }      }  }</code></pre><ul><li>NIOyyjClient.java   </li></ul><pre><code class="java"><span class="keyword">package</span> com.yyj.nio;<span class="keyword">import</span> java.net.InetSocketAddress;<span class="keyword">import</span> java.nio.ByteBuffer;<span class="keyword">import</span> java.nio.channels.SelectionKey;<span class="keyword">import</span> java.nio.channels.Selector;<span class="keyword">import</span> java.nio.channels.SocketChannel;<span class="keyword">import</span> java.util.Date;<span class="keyword">import</span> java.util.Iterator;<span class="comment">/** * Created by GraceYang on 2017/4/7. */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOyyjClient</span> </span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>{        SocketChannel socketChannel=SocketChannel.open();<span class="comment">// 获得一个Socket通道</span>        socketChannel.configureBlocking(<span class="keyword">false</span>);<span class="comment">// 设置通道为非阻塞</span>        Selector selector=Selector.open();<span class="comment">// 获得一个通道管理器</span>        InetSocketAddress address=<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">8000</span>);        <span class="comment">// 客户端连接服务器,其实方法执行并没有实现连接，需要在listen（）方法中调用channel.finishConnect();才能完成连接</span>        socketChannel.connect(address);        <span class="comment">//将通道管理器和该通道绑定，并为该通道注册SelectionKey.OP_CONNECT事件。</span>        socketChannel.register(selector, SelectionKey.OP_CONNECT);        <span class="keyword">while</span> (<span class="keyword">true</span>){            selector.select();            Iterator iterator=selector.selectedKeys().iterator(); <span class="comment">// 获得selector中选中的项的迭代器</span>            <span class="keyword">while</span> (iterator.hasNext()){                SelectionKey key=(SelectionKey) iterator.next();                iterator.remove();<span class="comment">// 删除已选的key,以防重复处理</span>                <span class="keyword">if</span>(key.isConnectable()){ <span class="comment">// 连接事件发生</span>                    SocketChannel socketChannel1=(SocketChannel)key.channel();                    <span class="keyword">if</span>(socketChannel1.isConnectionPending()){<span class="comment">// 如果正在连接，则完成连接</span>                        socketChannel1.finishConnect();                    }                    socketChannel1.configureBlocking(<span class="keyword">false</span>);<span class="comment">// 设置成非阻塞</span>                    <span class="comment">//给服务端发送信息</span>                    socketChannel1.write(ByteBuffer.wrap(<span class="keyword">new</span> String(<span class="string">"向服务端发送当前时间"</span>+<span class="keyword">new</span> Date()).getBytes()));                    <span class="comment">//在和服务端连接成功之后，为了可以接收到服务端的信息，需要给通道设置读的权限。</span>                    socketChannel1.register(selector,SelectionKey.OP_READ);                }               <span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()){<span class="comment">// 获得了可读的事件,处理读取服务端发来的信息的事件</span>                    SocketChannel socketChannel1=(SocketChannel)key.channel();                    ByteBuffer buf=ByteBuffer.allocate(<span class="number">100</span>);                    socketChannel1.read(buf);                    <span class="keyword">byte</span>[] data = buf.array();                    String msg = <span class="keyword">new</span> String(data).trim();                    System.out.println(<span class="string">"客户端收到信息："</span>+msg);                }            }        }    }}</code></pre><ul><li>运行结果：  </li></ul><p>NIOyyjServer：</p><p>服务端收到信息：向服务端发送当前时间Mon Apr 10 15:11:46 CST 2017</p><p>NIOyyjClient：</p><p>客户端收到信息：向客户端发送当前时间Mon Apr 10 15:11:49 CST 2017  </p><p><img src="/images/scenery.JPG" alt=""></p><blockquote><p>参考书籍：《Hadoop技术内幕：深入解析Hadoop Common和HDFS架构设计与实现原理》</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、为什么出现Java-NIO&quot;&gt;&lt;a href=&quot;#一、为什么出现Java-NIO&quot; class=&quot;headerlink&quot; title=&quot;一、为什么出现Java NIO&quot;&gt;&lt;/a&gt;一、为什么出现Java NIO&lt;/h4&gt;&lt;p&gt;由于Java的OutputStream和InputStream没有提供异步I/O的能力，OutputStream上的写操作write()方法会阻塞直至数据被成功写入，InputStream上的读操作read()方法也会阻塞，直到有数据可读，还有ServerSocket的accept()方法也会阻塞直至有客户端进行连接。它们都是阻塞方法，那当服务器需要处理上千个客户请求时，往往就需要一个客户对应一个线程，大量的闲置客户端会限制系统可以同时服务的客户端总数，所以JDK1.4引入了Java NIO(New Input/Output)。&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://gracee.xin/tags/java/"/>
    
      <category term="moods" scheme="http://gracee.xin/tags/moods/"/>
    
      <category term="NIO" scheme="http://gracee.xin/tags/NIO/"/>
    
  </entry>
  
</feed>
